<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>larbraryy的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="劳于读书，逸于作文">
<meta name="keywords" content="ios 架构 读书">
<meta property="og:type" content="website">
<meta property="og:title" content="larbraryy的博客">
<meta property="og:url" content="https://hexoman.github.io/index.html">
<meta property="og:site_name" content="larbraryy的博客">
<meta property="og:description" content="劳于读书，逸于作文">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="larbraryy的博客">
<meta name="twitter:description" content="劳于读书，逸于作文">
  
    <link rel="alternate" href="/atom.xml" title="larbraryy的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">larbraryy的博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">专注于技术和生活</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://hexoman.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-深入理解计算机系统" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/17/深入理解计算机系统/" class="article-date">
  <time datetime="2019-06-16T16:00:00.000Z" itemprop="datePublished">2019-06-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/17/深入理解计算机系统/">深入理解计算机系统</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="冯-·-诺依曼体系"><a href="#冯-·-诺依曼体系" class="headerlink" title="冯 · 诺依曼体系"></a>冯 · 诺依曼体系</h2><p>几乎所有计算机程序都有一个经典的架构基础：冯 · 诺依曼体系。<br>包含运算器、控制器、存储器、输入和输出设备。</p>
<p><img src="../../images/冯诺依曼.png" alt="avatar"></p>
<h4 id="CPU主频和性能"><a href="#CPU主频和性能" class="headerlink" title="CPU主频和性能"></a>CPU主频和性能</h4><p>计算机常说的性能主要体现在两个指标。</p>
<ul>
<li>第一个是响应时间，或者说执行时间。响应时间越快越好，性能越好。</li>
<li>第二个是吞吐率，可以理解为相同时间内运行的更多。</li>
</ul>
<p>CPU的主频代表的就是时钟周期时间。比如2.8gGHZ，粗浅的认为CPU在一秒内执行简单指令的数量是 2.8G条。<br>这个时钟走的越快处理的事情就越多，性能就越好呢？其实不然，时钟跑的越快，付出的代价也越大，散热和功耗的压力也就越大，超过CPU承受范围就崩溃了。</p>
<p>CPU执行时间的公式：程序的CPU执行时间 = CPU时钟周期数 * 时钟周期时间</p>
<p>对于CPU时钟周期数，我们可以再做一个分解，把它变成“指令数 * 每条指令执行的平均时间周期数（CPI）”,不同的指令对应的CPI不同，乘法的CPI就比加法多。</p>
<h4 id="CPU的瓶颈"><a href="#CPU的瓶颈" class="headerlink" title="CPU的瓶颈"></a>CPU的瓶颈</h4><p>CPU其实是一个超大规模集成电路，由许多晶体管组合而成。CPU的计算，实际就是晶体管的开闭来进行的。<br>要想计算的快，有两方面的改善。一是增加晶体管密度，二是提升主频，即开闭的速度更快，但都会带来耗电和散热问题。</p>
<h4 id="优化性能可行的三个方向"><a href="#优化性能可行的三个方向" class="headerlink" title="优化性能可行的三个方向"></a>优化性能可行的三个方向</h4><ul>
<li>计算机主频，提升硬件性能。</li>
<li>CPU通过流水线技术，让每条指令的执行时间尽可能减少</li>
<li>控制指令的条数，主要优化在编译器层面</li>
<li>加速大概率事件。例如用GPU代替CPU计算来解决90%以上事件的速度提升</li>
<li>通过预测提高性能。在预测未来的情况下，提前进行相应的操作，来提升性能。</li>
</ul>
<h2 id="计算机指令执行的过程"><a href="#计算机指令执行的过程" class="headerlink" title="计算机指令执行的过程"></a>计算机指令执行的过程</h2><p>CPU就是执行各种计算机指令的大脑，CPU能识别的语言叫机器语言。<br>高级语言通过编译成为汇编代码，再用汇编器翻译成机器语言。常见的指令分为五大类。</p>
<ul>
<li>算术类指令。例如加减乘除</li>
<li>数据传输类指令。给变量赋值，在内存中读写数据</li>
<li>逻辑类指令。逻辑上的与和非</li>
<li>条件分支指令。if/else</li>
<li>无条件指令。函数调用</li>
</ul>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>一个CPU种有很多不同功能的寄存器，有三种比较特殊。</p>
<ul>
<li>PC寄存器（指令地址寄存器）存放下一条需要执行的计算机指令的内存地址</li>
<li>指令寄存器。存放当前执行的指令</li>
<li>条件码寄存器。里面用一个flag,存放CPU进行算术或者逻辑算计的结果</li>
</ul>
<p>一个程序执行时，CPU会根据PC寄存器里的地址，从内存中把需要执行的指令读取到指令寄存器执行，然后根据指令长度自增，开始读取下一条指令。</p>
<h4 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h4><p>当指令在原来顺序执行的过程中，执行了一个内存地址的跳转指令，让指令从原来顺序执行的过程中跳开，从新的跳转后位置执行。<br>但是还有一个场景：需要指令跳走其他指令执行完还能继续在当前位置执行。方法是在内存里开辟一个空间，用栈后进先出数据结构来关系指令的执行。</p>
<p>举个例子，在A中调用B，那么会在汇编中call指令发生时，将A压栈，此时栈顶是A。并在B函数第一行，通过push rbp压栈，栈顶是B。当B执行完，通过pop rbp出栈B。</p>
<p><img src="../../images/栈帧.png" alt="avatar"></p>
<p>栈里压入它存不下的内容，程序在执行的过程中就会遇到栈溢出的错误，即Stack Overflow。</p>
<h2 id="编译、链接、装载"><a href="#编译、链接、装载" class="headerlink" title="编译、链接、装载"></a>编译、链接、装载</h2><p>高级语言-&gt;汇编代码-&gt;机器码其实分为两部分。</p>
<ul>
<li>由编译、汇编、链接三个阶段组成。在这个阶段完成之后，就生成一个可执行文件</li>
<li>通过装载器把可执行文件装载到内存中，CPU从内存中读取指令和数据，来开始真正执行程序</li>
</ul>
<p>可执行文件一般包含如下几个Section:</p>
<ul>
<li>.text。也叫代码段或者指令段，用来保存程序的代码和指令</li>
<li>.data。也叫数据段，用来保存程序里面设置好的初始化数据信息</li>
<li>重定位表relocation Table。刚开始并不知道跳转地址的信息存储在重定位表中。</li>
<li>符号表（Symbol Table)。保留所说的当前文件里面定义的函数名称和对应地址的表</li>
</ul>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>链接器扫描所有的输入文件，然后把符号表信息收集起来，构成一个全局的符号表，然后根据重定位表，把所有不确定要跳转的代码，根据符号表里面存储的地址进行一次修正。最后把所有的目标文件的对应段进行一次合并，变成最终的可执行代码。</p>
<h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>在动态链接对应的共享库，我们在共享库的 data section里面保存了一张全局偏移表（GOT，Global Offset Table)。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。Got表里面的数据，则是在加载一个个共享库的时候写进去的。</p>
<p><img src="../../images/动态链接.png" alt="avatar"></p>
<h2 id="计算机指令的执行"><a href="#计算机指令的执行" class="headerlink" title="计算机指令的执行"></a>计算机指令的执行</h2><h3 id="指令的分类"><a href="#指令的分类" class="headerlink" title="指令的分类"></a>指令的分类</h3><ul>
<li>算术类指令。加减乘除</li>
<li>数据传输类指令。给变量赋值，在内存里读写数据</li>
<li>逻辑类指令。逻辑上的与或非</li>
<li>条件分支类指令。if/else</li>
<li>无条件跳转指令。函数调用</li>
</ul>
<h3 id="指令执行的过程"><a href="#指令执行的过程" class="headerlink" title="指令执行的过程"></a>指令执行的过程</h3><p>指令周期大致分为以下三个部分</p>
<ul>
<li>取得指令</li>
<li>指令译码</li>
<li>执行指令</li>
</ul>
<p>在取指令阶段，指令是存放在存储器里的，通过PC寄存器和指令寄存器取出指令的过程，是由控制器操作的，指令的解码过程，也是控制器进行的。指令的执行，则是由算术逻辑单元操作的（ALU），即运算器。</p>
<p>一个简易CPU的流程<br><img src="../../images/简单CPU.png" alt="avatar"></p>
<ul>
<li>首先，有一个自动计数器，随着时钟主频不断自增来作为PC寄存器</li>
<li>自动计数器连接上一个译码器，译码器同时连接大量的D触发器组成的内存</li>
<li>自动计数器不断自增，译码器找到对应的计数器所表示的内存地址，然后读取里面的CPU指令。</li>
<li>读取出来的CPU指令写入一个由D触发器组成的寄存器，也就是指令寄存器</li>
<li>在指令寄存器后面链接一个译码器，这个译码器的作用是解析指令为opcode和对应的操作数</li>
<li>拿到opcode和操作数，对应的输出线路连接ALU，开始计算各种算术和逻辑运算，对应的计算结果，在写入D触发器组成的寄存器或者内存中。</li>
</ul>
<h3 id="CPU面向流水线的指令设计"><a href="#CPU面向流水线的指令设计" class="headerlink" title="CPU面向流水线的指令设计"></a>CPU面向流水线的指令设计</h3><p>为了执行效率，现在CPU采用指令流水线设计方式。就是“取指令 - 指令译码 - 执行指令”这样三个部分每个步骤都独立，每个阶段的电路在完成对应的任务后，也不需要等待整个指令的执行完成，可以直接执行下一条指令的对应阶段。<br><img src="../../images/流水线执行.png" alt="avatar"></p>
<p>然而太深层次的流水线将带来性能瓶颈，所以流水线的层级是性能的一个权衡和取舍</p>
<h2 id="流水线冒险hazard和预测"><a href="#流水线冒险hazard和预测" class="headerlink" title="流水线冒险hazard和预测"></a>流水线冒险hazard和预测</h2><p>为什么会有流水线hazard ？<br>流水线指令的设计是每个独立的单元并不关心指令是否执行完成，就进行下一个步骤。但是这里一个问题是B指令依赖于A指令，那么冒险就存在了。</p>
<h3 id="流水线停顿"><a href="#流水线停顿" class="headerlink" title="流水线停顿"></a>流水线停顿</h3><p>对于同一个寄存器或者地址的操作，都有明确强制的顺序要求。发现后面执行的指令，会对前面执行的指令有数据层面的依赖关系，那么会执行等待。</p>
<h3 id="提高流水线性能的办法"><a href="#提高流水线性能的办法" class="headerlink" title="提高流水线性能的办法"></a>提高流水线性能的办法</h3><ul>
<li>操作数前推（操作数旁路），在硬件层面制作一条旁路，让上一条指令的计算结果没直接传给下一条指令，省略指令1写回寄存器，指令2再读取寄存器的操作。</li>
<li>乱序执行。后面不依赖前面数据的指令可以在前指令等待阶段先执行。<br><img src="../../images/CPU乱序执行.png" alt="avatar"></li>
<li>分支预测。通过对下一分支的预测执行来提高速度，假如一条执行预测执行if，那么会提前去执行if里面的指令，条件语句如果正确，那么继续预测的分支。否则就把后面已经取出指令已经执行的部分丢弃。</li>
</ul>
<h3 id="CPU-乱序执行"><a href="#CPU-乱序执行" class="headerlink" title="CPU 乱序执行"></a>CPU 乱序执行</h3><ul>
<li>在取执行和指令译码阶段，顺序执行</li>
<li>在指令译码完成之后，进行一次指令分发，把指令分发到保留站（Reservation Stations)</li>
<li>在保留站，指令不会立刻执行，而要等待它们的依赖的数据，传给它们之后才会执行。</li>
<li>一旦指令依赖数据到达之后，指令就交给后面的功能单元处理，即ALU。</li>
<li>指令执行完成之后，把结果存到一个重排序缓冲区（re-order Buffer）ROB</li>
<li>在ROB，CPU会按照原来取指令的顺序，对指令重新排序。只有排在前面的指令都完成了，才会提交指令，完成整个指令的运算结果。</li>
<li>实际的指令的计算结果，并不是直接写到内存或者高速缓存，而是写入存储缓冲区（store buffer),最终才会写入高速缓存区。</li>
</ul>
<h2 id="GPU的用途"><a href="#GPU的用途" class="headerlink" title="GPU的用途"></a>GPU的用途</h2><p>图像渲染的过程大致分为5个过程，称之为图形流水线 (Graphic Pipeline)</p>
<ul>
<li><p>顶点处理 (Vertex Processing)。构成多边形的建模是三维模型，有多个顶点。在二维屏幕视角时，需要把三维顶点坐标做个线性计算，转换到当前视角的坐标的过程。</p>
</li>
<li><p>图元处理 (Primitive Processsing)。将转化后的顶点坐标连接起来，剔除和裁剪屏幕内的一部分内容去除。</p>
</li>
<li><p>删格化 (Rasterization)。将多边形转换为屏幕的一个个像素点</p>
</li>
<li><p>片段处理 (Fragment Processing）。在图形转为像素之后，还需要计算每一个像素的颜色、透明度，给像素点上色。</p>
</li>
<li><p>像素操作 (Pixel Operations)。将不同图形的像素点混合，比如前一个半透明，后一个深色，那么混合之后展示一个新的颜色。最终输出到显示设备。</p>
</li>
</ul>
<h4 id="那么为什么不用CPU来做图形渲染呢？"><a href="#那么为什么不用CPU来做图形渲染呢？" class="headerlink" title="那么为什么不用CPU来做图形渲染呢？"></a>那么为什么不用CPU来做图形渲染呢？</h4><p>假如屏幕上有30万像素点需要渲染，按照60帧的FPS，那么要求一秒处理60 * 30 = 1800万次像素点。每个像素点有3个流水线步骤，即便每次步骤只有一个指令，需要5400万条指令，即54m指令。90年代的电脑主频不过100MHZ，以这个性能来处理图形渲染，CPU几乎超负荷运行。</p>
<p>所以用GPU这种硬件来处理渲染将解放CPU，大大提高性能。</p>
<h4 id="GPU的结构"><a href="#GPU的结构" class="headerlink" title="GPU的结构"></a>GPU的结构</h4><p>GPU不需要流水线处理，所以可以抽象为三个部分，取指令、指令译码、ALU和执行上下文。GPU中顶点处理和像素渲染都是独立，所以简单添加多核，就可以做到并行加速。<br><img src="../../images/原始GPU架构.png" alt="avatar"></p>
<h4 id="SIMT（Single-Instruction-Multiple-Threads-技术"><a href="#SIMT（Single-Instruction-Multiple-Threads-技术" class="headerlink" title="SIMT（Single Instruction Multiple Threads)技术"></a>SIMT（Single Instruction Multiple Threads)技术</h4><p>SIMT将多条数据，分给不同线程处理。<br><img src="../../images/GPU中的SIMT.png" alt="avatar"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/06/17/深入理解计算机系统/" data-id="cjxspmi6b0037yxon8a29te72" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-swift学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/04/swift学习笔记/" class="article-date">
  <time datetime="2019-05-03T16:00:00.000Z" itemprop="datePublished">2019-05-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/04/swift学习笔记/">swift学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h2><h3 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组  (Arrays)"></a>数组  (Arrays)</h3><h4 id="创建一个空数组"><a href="#创建一个空数组" class="headerlink" title="创建一个空数组"></a>创建一个空数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var someInts = [Int]()</span><br></pre></td></tr></table></figure>
<h4 id="创建一个带有默认值的数组"><a href="#创建一个带有默认值的数组" class="headerlink" title="创建一个带有默认值的数组"></a>创建一个带有默认值的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var test = Array(repeating: &quot;test&quot;, count: 3);</span><br><span class="line">//test是一个[String]数组，等价于[&quot;test&quot;,&quot;test&quot;,&quot;test&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="通过数组相加创建一个数组"><a href="#通过数组相加创建一个数组" class="headerlink" title="通过数组相加创建一个数组"></a>通过数组相加创建一个数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var one = Array(repeating: &quot;test&quot;, count: 3);</span><br><span class="line">var two = Array(repeating: &quot;hh&quot;, count: 3);</span><br><span class="line">var three = one + two;</span><br><span class="line">print(three);</span><br><span class="line">//[&quot;test&quot;, &quot;test&quot;, &quot;test&quot;, &quot;hh&quot;, &quot;hh&quot;, &quot;hh&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="访问和修改数组"><a href="#访问和修改数组" class="headerlink" title="访问和修改数组"></a>访问和修改数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if shoppingList.isEmpty &#123;</span><br><span class="line">    print(&quot;The shopping list is empty.&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    print(&quot;The shopping list is not empty.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用isEmpty作为一个缩写形式去检查count属性是否为0</span><br></pre></td></tr></table></figure>
<p>使用append(_:)增加新元素，也可以使用(+=) 直接在数组后面添加一个或者多个想通过类型的新元素</p>
<p>利用下标来一次改变一系列数据值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var list = [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;];</span><br><span class="line">list[2...3] = [&quot;five&quot;,&quot;six&quot;];</span><br><span class="line">print(list);</span><br><span class="line">//[&quot;one&quot;, &quot;two&quot;, &quot;five&quot;, &quot;six&quot;]</span><br></pre></td></tr></table></figure>
<p>可以使用remove(at:)和removeLast()来删除数组元素</p>
<h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><p>同时需要每个数据项的值和索引值，可以使用 enumerated() 方法来进行数组遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var list = [&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;];</span><br><span class="line">for (index, value) in list.enumerated() &#123;</span><br><span class="line">    print(&quot;Item \(String(index + 1)): \(value)&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//Item 1: one</span><br><span class="line">//Item 2: two</span><br><span class="line">//Item 3: three</span><br><span class="line">//Item 4: four</span><br></pre></td></tr></table></figure>
<h3 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合 (Set)"></a>集合 (Set)</h3><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var list: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</span><br><span class="line">var list: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</span><br></pre></td></tr></table></figure>
<p>创建一个制定string类型的集合，只能存储String类型。</p>
<h4 id="访问和修改集合"><a href="#访问和修改集合" class="headerlink" title="访问和修改集合"></a>访问和修改集合</h4><p>和数组一样，使用count属性找出Set元素的数量，isEmpty检查count是否为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.insert(&quot;Jazz&quot;)</span><br></pre></td></tr></table></figure>
<p>insert(_:) 方法来添加一个新元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.remove(&quot;Jazz&quot;)</span><br></pre></td></tr></table></figure>
<p>remove(_:) 方法来删除一个新元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if list.contains(&quot;Funk&quot;) &#123;</span><br><span class="line">    print(&quot;I get up on the good foot.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 contains(_:) 方法去检查 Set 中是否包含一个特定的值</p>
<h4 id="基本集合操作"><a href="#基本集合操作" class="headerlink" title="基本集合操作"></a>基本集合操作</h4><p><img src="../../images/swiftSet.png" alt="avatar"></p>
<ul>
<li>使用 intersection(_:) 方法根据两个集合中都包含的值创建的一个新的集合。</li>
<li>使用 symmetricDifference(_:) 方法根据在一个集合中但不在两个集合中的值创建一个新的集合。</li>
<li>使用 union(_:) 方法根据两个集合的值创建一个新的集合。</li>
<li>使用 subtracting(_:) 方法根据不在该集合中的值创建一个新的集合。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let oddDigits: Set = [1, 3, 5, 7, 9]</span><br><span class="line">let evenDigits: Set = [0, 2, 4, 6, 8]</span><br><span class="line">let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]</span><br><span class="line"></span><br><span class="line">oddDigits.union(evenDigits).sorted()</span><br><span class="line">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">oddDigits.intersection(evenDigits).sorted()</span><br><span class="line">// []</span><br><span class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()</span><br><span class="line">// [1, 9]</span><br><span class="line">oddDigits.symmetricDifference(singleDigitPrimeNumbers).sorted()</span><br><span class="line">// [1, 2, 9]</span><br></pre></td></tr></table></figure>
<h3 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典 (Dictionary)"></a>字典 (Dictionary)</h3><h4 id="创建一个空字典"><a href="#创建一个空字典" class="headerlink" title="创建一个空字典"></a>创建一个空字典</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var namesOfIntegers = [Int: String]()</span><br></pre></td></tr></table></figure>
<h4 id="访问和修改字典"><a href="#访问和修改字典" class="headerlink" title="访问和修改字典"></a>访问和修改字典</h4><p>通过字典的只读属性 count 来获取某个字典的数据项数量。<br>使用布尔属性 isEmpty 作为一个缩写形式去检查 count 属性是否为 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var dict = [&quot;key1&quot;:&quot;value1&quot;, &quot;key2&quot;:&quot;value2&quot;]</span><br><span class="line">if let oldValue = dict.updateValue(&quot;v3&quot;, forKey: &quot;key3&quot;) &#123;</span><br><span class="line">    print(&quot;The old value for key3 was \(oldValue).&quot;)</span><br><span class="line">&#125;</span><br><span class="line">print(dict)</span><br><span class="line">//[&quot;key2&quot;: &quot;value2&quot;, &quot;key3&quot;: &quot;v3&quot;, &quot;key1&quot;: &quot;value1&quot;]</span><br></pre></td></tr></table></figure>
<p>updateValue可以设置或者更新特性键对应的值，在key不存在的时候设置新值或者在已经存在key的情况下更新value。</p>
<p>removeValue(forKey:) 方法也可以用来在字典中移除键值对.</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h4 id="简单闭包格式"><a href="#简单闭包格式" class="headerlink" title="简单闭包格式"></a>简单闭包格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;]</span><br><span class="line">var reversedNames = names.sorted(by: &#123;(s1: String, s2: String) -&gt; Bool in</span><br><span class="line">    return s1 &gt; s2</span><br><span class="line">&#125;)</span><br><span class="line">print(reversedNames)</span><br><span class="line">//[&quot;Ewa&quot;, &quot;Daniella&quot;, &quot;Chris&quot;, &quot;Barry&quot;, &quot;Alex&quot;]</span><br></pre></td></tr></table></figure>
<p>上面用闭包实现数组的排序。</p>
<p>也可以这么简写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>单表达式闭包的隐式返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; )</span><br></pre></td></tr></table></figure>
<p>swift自动为内联闭包提供参数名称缩写，可以直接这么缩写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reversedNames = names.sorted(by: &#123;$0 &gt; $1&#125; )</span><br></pre></td></tr></table></figure></p>
<h4 id="尾随闭包"><a href="#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h4><p>函数支持将其作为最后一个参数调用。在使用尾随闭包时，不用写出它的参数标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 以下是不使用尾随闭包进行函数调用</span><br><span class="line">someFunctionThatTakesAClosure(closure: &#123;</span><br><span class="line">    // 闭包主体部分</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 以下是使用尾随闭包进行函数调用</span><br><span class="line">someFunctionThatTakesAClosure() &#123;</span><br><span class="line">    // 闭包主体部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逃匿闭包"><a href="#逃匿闭包" class="headerlink" title="逃匿闭包"></a>逃匿闭包</h4><p>当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行，我们称该闭包从函数中逃逸。当定义接受闭包作为参数的函数时，你可以在参数名之前标注 @escaping，用来指明这个闭包是允许“逃逸”出这个函数的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var customersInLine = [&quot;Chris&quot;, &quot;Alex&quot;]</span><br><span class="line">var customerProviders: [() -&gt; String] = []</span><br><span class="line">func collectCustomerProviders(_ customerProvider: @autoclosure @escaping () -&gt; String) &#123;</span><br><span class="line">    customerProviders.append(customerProvider)</span><br><span class="line">&#125;</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: 0))</span><br><span class="line">collectCustomerProviders(customersInLine.remove(at: 0))</span><br><span class="line"></span><br><span class="line">print(&quot;Collected \(customerProviders.count) closures.&quot;)</span><br><span class="line">// 打印“Collected 2 closures.”</span><br><span class="line">for customerProvider in customerProviders &#123;</span><br><span class="line">    print(&quot;Now serving \(customerProvider())!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h4 id="枚举成员的遍历"><a href="#枚举成员的遍历" class="headerlink" title="枚举成员的遍历"></a>枚举成员的遍历</h4><p>枚举的遍历需要遵循CaseIterable协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Planet:CaseIterable &#123;</span><br><span class="line">    case mercury, venus, earth, mars</span><br><span class="line">&#125;</span><br><span class="line">var directionToHead = Planet.allCases.count</span><br><span class="line">print(&quot;\(numberOfChoices) beverages available&quot;)</span><br><span class="line">// 打印“3 beverages available”</span><br></pre></td></tr></table></figure>
<p>通过allCases来遍历枚举中的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Planet:CaseIterable &#123;</span><br><span class="line">    case mercury, venus, earth, mars</span><br><span class="line">&#125;</span><br><span class="line">for beverage in Planet.allCases &#123;</span><br><span class="line">    print(beverage)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="隐式赋值"><a href="#隐式赋值" class="headerlink" title="隐式赋值"></a>隐式赋值</h4><p>枚举定义为Int或者String时，不需要显式地为每一个枚举成员设置原始值，swift自动赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum Planet: Int &#123;</span><br><span class="line">    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum CompassPoint: String &#123;</span><br><span class="line">    case north, south, east, west</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let earthsOrder = Planet.earth.rawValue</span><br><span class="line">// earthsOrder 值为 3</span><br><span class="line"></span><br><span class="line">let sunsetDirection = CompassPoint.west.rawValue</span><br><span class="line">// sunsetDirection 值为 &quot;west&quot;</span><br></pre></td></tr></table></figure>
<h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p>下标允许通过在实例名称后面的方括号中传入一个或者多个索引值来对实例进行存取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct TimesTable &#123;</span><br><span class="line">    let multiplier: Int</span><br><span class="line">    subscript(index: Int) -&gt; Int &#123;</span><br><span class="line">        return multiplier * index</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let threeTimesTable = TimesTable(multiplier: 3)</span><br><span class="line">print(&quot;six times three is \(threeTimesTable[6])&quot;)</span><br><span class="line">// 打印“six times three is 18”</span><br></pre></td></tr></table></figure>
<h2 id="open-public-internal-fileprivate-private的区别"><a href="#open-public-internal-fileprivate-private的区别" class="headerlink" title="open/public/internal/fileprivate/private的区别"></a>open/public/internal/fileprivate/private的区别</h2><ul>
<li>open 任意地方访问、继承和重写</li>
<li>public 可以在任意的地方被访问、在其他module内不能被继承和重写</li>
<li>internal 默认访问级别，整个模块都能被访问</li>
<li>fileprivate修饰的属性可以在同一个文件被访问、继承和重写（同一个文件可以多个类，这点和private有区别)</li>
<li>private只能在本类访问和使用，不包括扩展类</li>
</ul>
<p>ps: module内和module外的区别。 module内是指不需要使用import引用文件，就可以创建对象，表示module内，而module外是指需要使用import文件才能创建对象才能使用。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="异变方法要求-（mutating）"><a href="#异变方法要求-（mutating）" class="headerlink" title="异变方法要求 （mutating）"></a>异变方法要求 （mutating）</h3><p>有时需要在方法中改变方法所属的实例，则可以在值类型（结构体和枚举）的实例方法中，将 mutating 关键字作为方法的前缀</p>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><p>require 可以在实现协议的类中添加构造器，使用required 修饰符可以确保所有子类也必须提供此构造器实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeProtocol &#123;</span><br><span class="line">    init(someParameter: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeClass: SomeProtocol &#123;</span><br><span class="line">    required init(someParameter: Int) &#123;</span><br><span class="line">        // 这里是构造器的实现部分</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SomeSubClass:SomeClass  &#123;</span><br><span class="line">    func test() &#123;</span><br><span class="line">        print(&quot;test&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    //SomeSubClass作为SomeClass的子类，如果在父类中用required修饰构造函数，那么子类也必须实现构造函数，否则将报错</span><br><span class="line">    required init(someParameter: Int) &#123;</span><br><span class="line">        super.init(someParameter: someParameter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let sub = SomeSubClass(someParameter: 123)</span><br><span class="line">sub.test()</span><br></pre></td></tr></table></figure>
<h3 id="协议的一些特点"><a href="#协议的一些特点" class="headerlink" title="协议的一些特点"></a>协议的一些特点</h3><ul>
<li>可以当作类型传参，可以作为数组、字典的元素类型</li>
<li>可以扩展</li>
<li>在扩展里声明采纳协议</li>
<li>可以继承</li>
<li>可以通过 is as? as!来检查协议的类型</li>
<li>协议可以合成</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protocol Named &#123;</span><br><span class="line">    var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">protocol Aged &#123;</span><br><span class="line">    var age: Int &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Person: Named, Aged &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var age: Int</span><br><span class="line">&#125;</span><br><span class="line">func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123;</span><br><span class="line">    print(&quot;Happy birthday, \(celebrator.name), you&apos;re \(celebrator.age)!&quot;)</span><br><span class="line">&#125;</span><br><span class="line">let birthdayPerson = Person(name: &quot;Malcolm&quot;, age: 21)</span><br><span class="line">wishHappyBirthday(to: birthdayPerson)</span><br></pre></td></tr></table></figure>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">struct Stack&lt;Element&gt; &#123;</span><br><span class="line">    var items = [Element]()</span><br><span class="line">    mutating func push(_ item: Element) &#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    mutating func pop() -&gt; Element &#123;</span><br><span class="line">        return items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var stackOfStrings = Stack&lt;String&gt;()</span><br><span class="line">stackOfStrings.push(&quot;uno&quot;)</span><br><span class="line">stackOfStrings.push(&quot;dos&quot;)</span><br><span class="line">stackOfStrings.push(&quot;tres&quot;)</span><br><span class="line">stackOfStrings.push(&quot;cuatro&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//泛型可以扩展</span><br><span class="line">extension Stack &#123;</span><br><span class="line">    var topItem: Element? &#123;</span><br><span class="line">        return items.isEmpty ? nil : items[items.count - 1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stackOfStrings.pop()</span><br><span class="line">if let topItem = stackOfStrings.topItem &#123;</span><br><span class="line">    print(&quot;The top item on the stack is \(topItem).&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="默认构造"><a href="#默认构造" class="headerlink" title="默认构造"></a>默认构造</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct Celsius &#123;</span><br><span class="line">    var response : String?</span><br><span class="line">    var text : String?</span><br><span class="line">    func ask() &#123;</span><br><span class="line">        print(text ?? &quot;unknow&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//默认构造</span><br><span class="line">let cheeseQuestion = Celsius()  </span><br><span class="line"></span><br><span class="line">//结构体的逐一成员构造器，class不支持</span><br><span class="line">let cheeseQuestion = Celsius(response: &quot;t&quot;,text: &quot;Test&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="自定义构造过程"><a href="#自定义构造过程" class="headerlink" title="自定义构造过程"></a>自定义构造过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//结构体和class都支持自定义构造</span><br><span class="line">struct Celsius &#123;</span><br><span class="line">    var response : String?</span><br><span class="line">    var text : String?</span><br><span class="line">    init(text: String, response: String) &#123;</span><br><span class="line">        self.text = text</span><br><span class="line">        self.response = response</span><br><span class="line">    &#125;</span><br><span class="line">    func ask() &#123;</span><br><span class="line">        print(text ?? &quot;unknow&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cheeseQuestion = Celsius(text: &quot;test&quot;,response: &quot;t&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="swift的关键字"><a href="#swift的关键字" class="headerlink" title="swift的关键字"></a>swift的关键字</h2><ul>
<li>typealias  用来为已经存在的类型重新定义名字。1.可以定义闭包，类似OC中的typedef。2.将多个protocol组合成一个然后重新命名。</li>
<li>defer block 里的代码会在函数 return 之前执行，无论函数是从哪个分支 return 的，还是有 throw，还是自然而然走到最后一行</li>
<li>discardableResult 忽略一个方法返回值没有使用的警告</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/05/04/swift学习笔记/" data-id="cjxspmi670034yxonrjx5h4y7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-汇编入门学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/01/汇编入门学习/" class="article-date">
  <time datetime="2019-03-31T16:00:00.000Z" itemprop="datePublished">2019-04-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/汇编/">汇编</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/01/汇编入门学习/">汇编入门学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul>
<li><p>通用寄存器（用来存放一般性数据）</p>
<ul>
<li>x0-x30(64位）</li>
<li>x29又名 fp(用于保存栈底地址）</li>
<li>x30又名 lr(bl跳转后就把下一条指令写到lr中）</li>
<li>w0-w30（32位）</li>
</ul>
</li>
<li><p>浮点寄存器 (CPU中专门提供浮点数寄存器来处理浮点数)</p>
<ul>
<li>D0-D31(64位)</li>
<li>S0-S31(32位）</li>
</ul>
</li>
<li><p>向量寄存器（现在的CPU支持向量运算，向量运算在图形处理相关的领域用得非常的多）</p>
<ul>
<li>V0 - V31（128位）</li>
</ul>
</li>
<li><p>状态寄存器</p>
<ul>
<li>N【负数标志】、Z【0标志】、C【进位标志】、V【溢出标志】均为条件码标志位</li>
</ul>
</li>
<li><p>栈寄存器</p>
<ul>
<li>SP（任意时刻保存栈顶的地址）</li>
<li>FP（保存栈底的地址）</li>
</ul>
</li>
</ul>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><ul>
<li>mov x1, x0; 将寄存器x0的值传送到x1</li>
<li>add x0, x1, x2; 将寄存器x1和x2值相加后传到x0</li>
<li>sub x0, x1, x2; 将寄存器x1和x2值相减后传到x0</li>
<li>and x0, x0, #0xf; x0的值和0xf相与后值传给x0</li>
<li>or x0, x0, #9; x0的值和0xf相或后值传给x0</li>
<li>eor x0, x0, #0xf; x0的值和0xf相异或后值传给x0</li>
</ul>
<h3 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h3><ul>
<li>STR 将数据从寄存器中读取出来，保存到内存中<br>STR X0, [SP, #0x8]; X0寄存器数据传送到SP+0x8地址指向的存储空间</li>
<li>STP STR的变种指令，可以同时操作两个寄存器<br>STP x29, x30, [sp, #0x10]; 将x29和x30寄存器的数据存入sp+0x10所在栈中</li>
<li><p>LDR 将数据从内存中读取出来，存到寄存器中<br>LDR x5, [x6, #0x08]; x6寄存器加0x08地址值内的数据传到x5</p>
</li>
<li><p>LDP LDR的变种指令，可以同时操作两个寄存器<br>LDP x29, x30, [sp, #0x10] ; 将栈中的值取出存放到x29, x30</p>
</li>
</ul>
<h3 id="跳转操作"><a href="#跳转操作" class="headerlink" title="跳转操作"></a>跳转操作</h3><ul>
<li>b </li>
<li>bl 将下一条指令地址放入lr(x30)寄存器</li>
<li>ret 默认使用lr(x30)寄存器的值，通过底层指令提示CPU此处作为下条指令地址</li>
<li>cmp 比较指令。<ul>
<li>b.gt比较结果是大于，执行标号，否则不跳转</li>
<li>b.ge 比较结果是大于等于，执行标号，否则不跳转</li>
<li>b.eq 比较结果是等于，执行标号，否则不跳转</li>
<li>b.hi 比较结果是无符号大于，执行标号，否则不跳转</li>
</ul>
</li>
<li>cbz 如果寄存器的值==0，则跳转到地址，如果不等于0，则继续执行代码</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/04/01/汇编入门学习/" data-id="cjxspmi540018yxonv7x76o63" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS中的链接器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/27/iOS中的链接器/" class="article-date">
  <time datetime="2019-03-26T16:00:00.000Z" itemprop="datePublished">2019-03-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/27/iOS中的链接器/">iOS中的链接器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>新建一个Person类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Person : NSObject</span><br><span class="line">- (void)say;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Person</span><br><span class="line">- (void)say &#123;</span><br><span class="line">   NSLog(@&quot;test&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p>
<p>在main中引用Person</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Cocoa/Cocoa.h&gt;</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    Person *person = [[Person alloc] init];</span><br><span class="line">    [person say];</span><br><span class="line">    return NSApplicationMain(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang -c Person.m</span><br><span class="line">xcrun clang -c main.m</span><br></pre></td></tr></table></figure>
<p>将多个编译好的文件链接起来，生成.out可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun clang Person.o main.o -Wl,`xcrun --show-sdk-path`/System/Library/Frameworks/Foundation.framework/Foundation</span><br></pre></td></tr></table></figure>
<p>nm工具查看Person.o文件的符号  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun nm -nm Person.o</span><br></pre></td></tr></table></figure>
<p>打印内容如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(undefined) external _NSLog</span><br><span class="line">(undefined) external _OBJC_CLASS_$_NSObject</span><br><span class="line">(undefined) external _OBJC_METACLASS_$_NSObject</span><br><span class="line">(undefined) external ___CFConstantStringClassReference</span><br><span class="line">(undefined) external __objc_empty_cache</span><br><span class="line">0000000000000000 (__TEXT,__text) non-external -[Person say]</span><br><span class="line">0000000000000058 (__DATA,__objc_const) non-external l_OBJC_METACLASS_RO_$_Person</span><br><span class="line">00000000000000a0 (__DATA,__objc_const) non-external l_OBJC_$_INSTANCE_METHODS_Person</span><br><span class="line">00000000000000c0 (__DATA,__objc_const) non-external l_OBJC_CLASS_RO_$_Person</span><br><span class="line">0000000000000108 (__DATA,__objc_data) external _OBJC_METACLASS_$_Person</span><br><span class="line">0000000000000130 (__DATA,__objc_data) external _OBJC_CLASS_$_Person</span><br></pre></td></tr></table></figure>
<ul>
<li>(undefined) external 表示未实现非私有，私有就是non-external</li>
<li>undefined符号表示该文件未定义，在目标文件和Fundation动态库做链接时，链接器会尝试解析所有undefined符号。</li>
</ul>
<p>查看.out符号表 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun nm -nm a.out</span><br></pre></td></tr></table></figure>
<p>打印如下,可以看到会记录每个符号是哪个动态库解析的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(undefined) external _NSLog (from Foundation)</span><br><span class="line">(undefined) external _OBJC_CLASS_$_NSObject (from libobjc)</span><br><span class="line">(undefined) external _OBJC_METACLASS_$_NSObject (from libobjc)</span><br><span class="line">(undefined) external ___CFConstantStringClassReference (from CoreFoundation)</span><br><span class="line">(undefined) external __objc_empty_cache (from libobjc)</span><br><span class="line">(undefined) external _objc_msgSend (from libobjc)</span><br><span class="line">(undefined) external dyld_stub_binder (from libSystem)</span><br><span class="line">0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header</span><br><span class="line">0000000100000ee0 (__TEXT,__text) non-external -[Person say]</span><br><span class="line">0000000100000f10 (__TEXT,__text) external _main</span><br><span class="line">0000000100001120 (__DATA,__objc_data) external _OBJC_METACLASS_$_Person</span><br><span class="line">0000000100001148 (__DATA,__objc_data) external _OBJC_CLASS_$_Person</span><br></pre></td></tr></table></figure>
<p>可以通过otool工具来查看所需的库在哪</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dst56466:TestRuntime zw$ xcrun otool -L a.out</span><br><span class="line">a.out:</span><br><span class="line">/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation (compatibility version 300.0.0, current version 1560.12.0)</span><br><span class="line">/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)</span><br><span class="line">/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation (compatibility version 150.0.0, current version 1560.12.0)</span><br><span class="line">/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/03/27/iOS中的链接器/" data-id="cjxspmi4f0004yxond0pxm9cz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-&lt;&lt;程序员的自我修养&gt;&gt;之链接" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/<<程序员的自我修养>>之链接/" class="article-date">
  <time datetime="2019-03-23T16:00:00.000Z" itemprop="datePublished">2019-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/<<程序员的自我修养>>之链接/">&lt;&lt;程序员的自我修养&gt;&gt;之链接</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="链接做了什么"><a href="#链接做了什么" class="headerlink" title="链接做了什么"></a>链接做了什么</h2><p>程序设计的模块化是开发者一直追求的目标，当一个系统十分复杂时，每个源代码块都独立的编译，然后组装起来，这个组装的过程就是链接。链接的作用就是把各个模块之间的相互引用处理好，使得各个模块之间能够正确的衔接。链接的过程包括了地址和空间分配、符号决议、重定位等步骤。<br>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A文件中包含宇哥全局变量var,B文件需要访问这个var。mov S0x21, var</span><br><span class="line">在编译B文件时，编译器并不知道 var的目标地址，所以编译器在没有确定地址的情况下，将mov指令的目标地址置为0，等待链接器将AB链接以来以后再修正。var地址被修正的过程叫重定位。</span><br></pre></td></tr></table></figure>
<h2 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h2><p>编译器编译源代码后生成的文件叫做目标文件。包含机器指令代码、数据，以及链接时需要的符号表、调试信息、字符串。</p>
<p><img src="../../images/linked.png" alt="avatar"></p>
<p>以EFL为例，目标文件开头是一个头文件File Header，包含文件是否可以执行、是静态链接还是动态链接及入口地址、目标硬件和目标操作系统等信息。还包含一个段表，描述了各个段再文件中的偏移位置和属性。</p>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>讲两个或者多个目标文件链接起来形成一个可执行文件的过程叫做静态链接。<br>为了更好的节省空间，静态链接采用的是相似段合并（两步链接）。</p>
<p>第一步，<strong>空间和地址分配</strong> 扫描所有目标文件，获取它们各个段的长度、属性和位置，并且将目标文件中的符号表中的所有符号定义和符号引用收集起来，放到一个统一的全局符号表中。这一步，链接器获取到所有的段长度，并将它们合并，计算出文件中各个段合并之后的长度和位置，并建立映射关系。</p>
<p>第二步，<strong>符号解析和重定位</strong> 读取上步收集到的信息（段的数据、重定位信息）并且进行符号解析和重定位、调整代码中的地址。</p>
<h2 id="装载的方式"><a href="#装载的方式" class="headerlink" title="装载的方式"></a>装载的方式</h2><p>动态装载的基本原理就是将程序中常用的部分驻留在内存中，将一些不常用的数据放入磁盘里面。</p>
<ul>
<li>页映射：虚拟存储机制的一部分。</li>
</ul>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>基本思路是等到运行时才对目标程序进行链接。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/03/24/<<程序员的自我修养>>之链接/" data-id="cjxspmi4b0001yxonvs40f50m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解msg_send()" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/深入理解msg_send()/" class="article-date">
  <time datetime="2019-03-21T16:00:00.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/深入理解msg_send()/">深入理解msg_send</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="AutoreleasePool源码解析"><a href="#AutoreleasePool源码解析" class="headerlink" title="AutoreleasePool源码解析"></a>AutoreleasePool源码解析</h2><h3 id="AutoreleasePool结构"><a href="#AutoreleasePool结构" class="headerlink" title="AutoreleasePool结构"></a>AutoreleasePool结构</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/03/22/深入理解msg_send()/" data-id="cjxspmi57001gyxonorurf6bu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解isa指针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/15/深入理解isa指针/" class="article-date">
  <time datetime="2019-03-14T16:00:00.000Z" itemprop="datePublished">2019-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOS/">iOS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/15/深入理解isa指针/">深入理解isa指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <strong>OC类有几个重要的概念，instance、class object、metaclass、isa 这篇从源码的角度探究它们的实现。</strong></p>
<h3 id="instance对象实例"><a href="#instance对象实例" class="headerlink" title="instance对象实例"></a>instance对象实例</h3><p>创建一个对象或者实例其实就是一个objc_object结构体，只包含一个Class类型的isa，isa指针是指向对象所属的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">   Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// A pointer to an instance of a class.</span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;Hello World&quot;;</span><br></pre></td></tr></table></figure>
<p>str的本质是一个objc_object，isa指针则指向NSString这个类对象</p>
<h3 id="类对象-class-object"><a href="#类对象-class-object" class="headerlink" title="类对象 class object"></a>类对象 class object</h3><p>2.0之前的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY; </span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class      //父类                          OBJC2_UNAVAILABLE;                  </span><br><span class="line">    const char * _Nonnull name       //类的名字                          OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                     //版本                        OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size               //实例大小                           OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars   //实例变量列表                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;                            //方法列表    </span><br><span class="line">    struct objc_cache * _Nonnull cache        //缓存                  OBJC2_UNAVAILABLE;    </span><br><span class="line">    struct objc_protocol_list * _Nullable protocols    //协议      OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>类对象结构如上，主要是objc_class结构体。第一个元素也是一个isa指针，类对象的isa指向元类（metaClass), 元类中保存了创建类对象和类方法的所有信息。<br>如下这张图很好的解释了，实例和类对象、元类以及它们父类之间的关系。<br><img src="../../images/class_object.png" alt="avatar"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OBJC_EXPORT Class _Nullable</span><br><span class="line">object_getClass(id _Nullable obj) </span><br><span class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0, 2.0);</span><br></pre></td></tr></table></figure>
<p>object_getClasss用来获取isa指针的指向。</p>
<p>2.0之后的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line"> </span><br><span class="line">@interface Object &#123; </span><br><span class="line">    Class isa; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@interface NSObject &lt;NSObject&gt; &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    // Class ISA;</span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             // formerly cache pointer and vtable</span><br><span class="line">    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来可以关注下 isa_t里的内容,isa_t是一个union类型的的结构体，union内的变量共享一段内存。并且union占用内存的大小等于其内占用内存最大的变量大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">union isa_t </span><br><span class="line">&#123;</span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isa的初始化</p>
<p>当我们对一个 ObjC 对象分配内存时，其方法调用栈中包含了上述的两个方法，这里关注的重点是 initIsa 方法。访问对象的 isa 会直接返回一个指向 cls 的指针，magic 的值为 0x3b 用于调试器判断当前对象是真的对象还是没有初始化的空间.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">inline void </span><br><span class="line">objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, true, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line">inline void </span><br><span class="line">objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    if (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/03/15/深入理解isa指针/" data-id="cjxspmi56001eyxon721z9381" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/isa/">isa</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记之&lt;&lt;深入解析MAC OS X &amp; iOS操作系统&gt;&gt;(四)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/15/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(四)/" class="article-date">
  <time datetime="2019-03-14T16:00:00.000Z" itemprop="datePublished">2019-03-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/15/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(四)/">读书笔记之&lt;&lt;深入解析MAC OS X &amp; iOS操作系统&gt;&gt;（四）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 第四部分主要讲解Mach的虚拟内存。</p>
<h2 id="虚拟内存架构"><a href="#虚拟内存架构" class="headerlink" title="虚拟内存架构"></a>虚拟内存架构</h2><p>虚拟内存的抽象是Mach中提供最重要的机制，主要通过内存对象和分页器的形式提供的。</p>
<ol>
<li>虚拟内存层</li>
</ol>
<ul>
<li>vm_map: 表示任务地址空间内一个或多个虚拟内存区域。每个区域都由一个独立的条目（vm_map_entry),这些条目由一个双向链表vm_map_links维护</li>
<li>vm_map_entry：每一个vm_map_entry表示虚拟内存中一块连续的区域，每一个区域都可以通过指定的保护权限进行保护。vm_map_entry通常指向一个vm_object, 但也可以指向一个嵌套的 vm_map,即子映射。</li>
<li>vm_object: 将vm_map_entry和实际的支撑的内存关联起来。包含一个vm_page\链表，还包含一个用于访问正确分页器的Mach端口（memory_object),通过这个分页器进行页面的清理和获取操作。</li>
<li>vm_page: vm_page真正表示了vm_object或部分vm_object。vm_page 可以有多种状态：驻留内存、交换出、加密、干净和脏。</li>
</ul>
<ol start="2">
<li>物理内存<br>物理内存的层面处理的是虚拟内存到物理内存的映射。这个层面只有一个抽象pmap, 提供了机器无关的接口。这个接口隐藏了底层平台的细节，底层的细节需要处理器层次进行分页操作，其重要处理的对象包括硬件页表项（page table entry, PTE）、翻译查找表（translation lookaside buffer, TLB）</li>
</ol>
<p>vm_map结构体构成如下图.vm_map表示vm_map.size字节的内存，这些内存通过一个包含vm_map.hdr.nentries条目的链表（vm_map.hdr.links）维护。链表中每一项都是一个vm_map_entry,一个vm_map_entry表示虚拟内存中的一个连续的块。</p>
<p>  <img src="../../images/vm_map_header.png" alt="avatar"></p>
<p>  <img src="../../images/vm_map.png" alt="avatar"></p>
<p>vm_map_entry结构体构成如下图。vm_map_entry关键元素是vm_map_object,这是一个联合体，即可以包含另一个vm_map,也可以包含一个vm_object_t。</p>
<p>  <img src="../../images/vm_map_entry.png" alt="avatar"></p>
<p>vm_object是一个巨大的数据结构，这里重点关注三个字段：</p>
<ul>
<li>memq: vm_page对象的链表，每一项都代表一个驻留内存的虚拟内存页面。尽管一个对象可以表示一个单独的页面，但是大部分情况下一个对象可以包含多个页面。</li>
<li>pager:指向分页器的Mach端口。分页器将未驻留内存的页面关联到后备存储，后备存储可以是内存映射的文件、设备和交换文件，后备存储保存了没有驻留内存的页面。</li>
</ul>
<h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><p>XNU构建于Mach的物理内存抽象层之上，这个抽象层称为pmap。</p>
<p><img src="../../images/pmap.png" alt="avatar"></p>
<h2 id="Mach-Zone"><a href="#Mach-Zone" class="headerlink" title="Mach Zone"></a>Mach Zone</h2><p>Zone是一种内存区域，用于快速分配和释放频繁使用的固定大小的对象。内核使用，用户态不能访问。</p>
<p><img src="../../images/zone.png" alt="avatar"></p>
<p>如果系统内存不足，zone可能会进行垃圾回收。首先扫描所有的zone（跳过标记为不可回收的zone),检查这些zone的空闲列表，判断哪些是可以回收的。然后将这些对象转为页面：和非空闲对象共享了一个页面的对象不能释放，只有页面全部空闲的对象才能释放。</p>
<h2 id="内核内存分配器"><a href="#内核内存分配器" class="headerlink" title="内核内存分配器"></a>内核内存分配器</h2><p>内核的分配器函数负责分配虚拟内存，并且做好后备物理内存的映射。</p>
<ul>
<li>kernel_memory_allocate() 所有内核分配路径都会经过kernel_memory_allocate（）。这个函数执行实际的内存分配。同时对vm_map和pmap操作。这个函数在传入的vm_map中找到一个足够大的虚拟地址空间，然后从联动的页面列表中找出满足分配的内存。</li>
</ul>
<p><img src="../../images/kernel_memory_allocate.png" alt="avatar"></p>
<p>——————————————————</p>
<p>此处未完待续。。。</p>
<p>——————————————————</p>
<h2 id="BSD层"><a href="#BSD层" class="headerlink" title="BSD层"></a>BSD层</h2><h3 id="BSD-内存管理和Jetsam"><a href="#BSD-内存管理和Jetsam" class="headerlink" title="BSD 内存管理和Jetsam"></a>BSD 内存管理和Jetsam</h3><p>虚拟内存管理是在Mach层进行的，Mach控制了分页器，并且向用户态导出各种消息接口。而用户态的开发者大部分只关注标准的POSIX调用，因此需要对这些Mach调用封装。</p>
<p>jetsam是一个低内存情形的处理机制。类似Linux的oom,最初的通途就是杀掉消耗太多内存的进程。</p>
<p><img src="../../images/jetsam.png" alt="avatar"></p>
<p>jetsam维护了两个列表：</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/03/15/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(四)/" data-id="cjxspmi5e001uyxonh5hy6m8f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记之&lt;&lt;深入解析MAC OS X &amp; iOS操作系统&gt;&gt;(三)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(三)/" class="article-date">
  <time datetime="2019-03-12T16:00:00.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(三)/">读书笔记之&lt;&lt;深入解析MAC OS X &amp; iOS操作系统&gt;&gt;（三）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> 第三部分终于说到了最为重要的内核架构模块。</p>
<h2 id="内核基础知识"><a href="#内核基础知识" class="headerlink" title="内核基础知识"></a>内核基础知识</h2><p>内核（kennel）是所有现在操作系统的核心。大致分为巨内核、微内核、混合内核</p>
<h3 id="巨内核"><a href="#巨内核" class="headerlink" title="巨内核"></a>巨内核</h3><p>  宏内核，仍然是UNIX和LINUX采用的主要内核架构。巨内核采用的方式是将所有内核功能——不论是基础功能还是高级功能——全部放入一个地址空间中。这种架构的内核中，线程调度、内存管理、文件系统、安全管理、设备驱动都在一起。<br>  <img src="../../images/巨内核.png" alt="avatar"></p>
<p>  所有内核功能都在同一个地址空间中。例如在linux中，32位应用程序可寻址的内存空间是4GB，其中1GB完全献给内核。这样设计的好处是：在巨内核架构中，从用户态到内核态切换非常高效，基本就是一次线程切换的开销。这是因为内核的内存页面映射在所有进程的地址空间中，也就是说除了硬件青汁的内核态和用户态之间的隔离外，两者之间没有任何分别。所有的进程，不论所有者还是功能，都包含一份内核内存的拷贝，这些拷贝都映射到同一组物理页面，而且是常驻内存的物理页面。这不仅节省宝贵的RAM，也避免了系统调用的重大开销。</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>   微内核只包含最核心的内核功能，只负责最关键的部分——任务调度和内存管理，其他功能都交给外部服务程序（用户态）完成。服务程序之间被完全隔离开，服务程序之间所有通信都由消息传递完成。消息机制允许将消息以及后续消息投递至服务程序的队列中排队，服务程序从队列中取出消息并以此处理。</p>
<p>   <img src="../../images/微内核.png" alt="avatar"></p>
<p>   微内核具有巨内核没有的优点：</p>
<ul>
<li>正确性。代码量小，可以遍历所有代码路径，验证代码功能的正确性。</li>
<li>稳定性和健壮性，可能发生的故障点少。由于所有其他功能都是在外部服务完成，有故障只需要重启受影响的服务程序即可恢复。</li>
<li><p>灵活性，以及对不同平台和架构的适配性。</p>
<p>缺点也相当明显——性能。微内核的消息传递在底层需要通过内存复制和数次上下文切换来实现，开销比较大。</p>
</li>
</ul>
<h3 id="混合内核"><a href="#混合内核" class="headerlink" title="混合内核"></a>混合内核</h3><p>兼具微内核和巨内核的好处。内核最核心部分支持底层服务、调度、进程通信IPC（Inter-Process communication)和虚拟内存，其他服务都实现在这个核心之外，但是也在内核态中。混合内核并没有微内核的健壮性，牺牲健壮性换来和巨内核一样的运行效率。</p>
<hr>
<p>那么思考一个问题：XNU是属于什么类型的内核？</p>
<p>从技术来说，XNU是一个混合内核。XNU的核心Mach最早就是一个真正的微内核，现在Mach的原语还是围绕消息传递的基础构建的，然后，消息通常是以指针的形式传递，并没有昂贵的复制操作，因为大部分的服务都是在同一地址空间中执行（因此也会归属为巨内核）。类似的，建立在Mach之上的BSD层一直是一个巨内核，这个子系统也在同一个地址空间中。在iOS中，XNU目前在4GB的地址空间中预留顶部2GB。</p>
<hr>
<h3 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h3><p>异常基本可以分为如下三种：</p>
<ul>
<li>错误（fault):指令遇到可以纠正的异常，并且处理器可以重新启动这条出现异常的指令。常见的例子是页异常，某个虚拟内存地址表示的页面不在物理RAM中发生页错误，出现页错误时，执行错误处理程序，完成后返回到生成这个错误的指令。</li>
<li>陷阱（trap):类似错误，但是处理完成后返回的是发生陷进指令之后的那条指令</li>
<li>中止(abort): 不可重启指令。如果一个错误发生两次，那么也没必要再重试了。</li>
</ul>
<p>中断是一个特殊组建产生的，这个组件称之为可编程中断控制器（programmable interrupt Controller, PIC),PIC接受来自系统总线上设备的消息，然后将消息分见到某一中断请求线上去，并设置活跃状态，这个中断被一个函数处理完成之后，重置这条线的状态。</p>
<h2 id="Mach内核"><a href="#Mach内核" class="headerlink" title="Mach内核"></a>Mach内核</h2><h3 id="Mach的设计原则"><a href="#Mach的设计原则" class="headerlink" title="Mach的设计原则"></a>Mach的设计原则</h3><p>mach中所有的东西都是通过自己的对象实现的。进程、虚拟内存、线程都是对象，所有对象都有自己属性。Mach的独特之处在于选择了通过消息传递的方式实现对象之间的通信。</p>
<h3 id="Mach消息"><a href="#Mach消息" class="headerlink" title="Mach消息"></a>Mach消息</h3><p>Mach中最基本的概念是消息，定义为透明的BLOB（binary large object,二进制大对象）。通过固定的包头进行封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct  &#123;</span><br><span class="line">  mach_msg_header_t header</span><br><span class="line">  mach_msg_body_t body</span><br><span class="line">&#125;mach_msg_base_t</span><br></pre></td></tr></table></figure>
<p>消息头的元数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct  &#123;</span><br><span class="line">  mach_msg_bits_t  msgh_bits //消息头的标志位</span><br><span class="line">  mach_msg_size_t  msgh_size //大小，以字节为单位</span><br><span class="line">  mach_port_t      msgh_remote_port//目标（发出的消息）或源（接受的消息）</span><br><span class="line">  mach_port_t      msgh_local_port//源（发出的消息）或目标（接受的消息）</span><br><span class="line"></span><br><span class="line">  mach_msg_size_t  mgsh_reserved //..</span><br><span class="line">  maach_msg_id_t   msgh_id;     //唯一ID</span><br><span class="line">&#125;mach_msg_header_t</span><br></pre></td></tr></table></figure></p>
<p>Mach消息原来是为真正的微内核架构而设计的，mach_msg()函数必须在发送者和接受者之间复制消息</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/03/13/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(三)/" data-id="cjxspmi5b001oyxon9vpog0cg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-读书笔记之&lt;&lt;深入解析MAC OS X &amp; iOS操作系统&gt;&gt;(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/13/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(二)/" class="article-date">
  <time datetime="2019-03-12T16:00:00.000Z" itemprop="datePublished">2019-03-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/读书/">读书</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/13/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(二)/">读书笔记之&lt;&lt;深入解析MAC OS X &amp; iOS操作系统&gt;&gt;（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、引导过程：EFI和iBoot"><a href="#一、引导过程：EFI和iBoot" class="headerlink" title="一、引导过程：EFI和iBoot"></a>一、引导过程：EFI和iBoot</h2><p>引导的过程是指从计算机通电一瞬间到CPU开始执行操作系统代码的整个过程。</p>
<h4 id="1-1-揭秘EFI"><a href="#1-1-揭秘EFI" class="headerlink" title="1.1 揭秘EFI"></a>1.1 揭秘EFI</h4><p>   BIOS是一个固定的程序，而且通常是封闭的。EFI是一套接口，更像一个运行时环境，规范了一组应用程序的编程接口，基于EFI的程序可以利用这些接口实现功能。EFI程序通常是引导加载器（苹果的Boot Camp)，或者一些诊断程序（苹果的硬件测试工具）。</p>
<p><img src="../../images/EFI架构图.png" alt="avatar"></p>
<p>EFI二进制程序实现了这样的原型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef EFI_SATTUS (EFIAPI *EFI_IMAGE_ENTER_POINT) </span><br><span class="line">(IN EFI_HANDLE ImageHandle, IN EFI_SYSTEM_TABLE SystemTable)</span><br></pre></td></tr></table></figure>
<h2 id="二、launchd"><a href="#二、launchd" class="headerlink" title="二、launchd"></a>二、launchd</h2><p> 整个用户环境启动的入口，作为系统中的第一个用户态进程，负责间接或直接的启动系统中的其他进程。launchd由内核直接启动，负责加载BSD子系统的主内核线程创建一个线程来执行bsainit_task。</p>
<h3 id="2-1-系统范围和用户范围的launchd"><a href="#2-1-系统范围和用户范围的launchd" class="headerlink" title="2.1 系统范围和用户范围的launchd"></a>2.1 系统范围和用户范围的launchd</h3><p>系统范围的launchd是不可能终止的，当系统关闭时，launchd也是最后一个退出的进程。<br>用户范围的launchd是在用户登陆时执行的，通过SSH远程登录也会创建launchd，iOS上只有一个launchd实例，即系统范围的实例</p>
<h3 id="2-2-多面手launchd"><a href="#2-2-多面手launchd" class="headerlink" title="2.2 多面手launchd"></a>2.2 多面手launchd</h3><p>launchd是用户态出现的第一个进程。当系统还在启动初期的时候，launchd是系统上唯一的进程。launchd身兼数职。</p>
<ul>
<li>init，init的职责是派生出各种各样的后台守护程序，设置好系统，然后转入后台，确保这些守护程序都活着，如果程序死了，launchd会重新派生出新的守护程序。</li>
<li>atd/crond 运行定时作业，即在指定时间运行指定的命令</li>
<li>inetd/xinetd 用途是启动网络服务。这个守护程序的职责是绑定一些端口（TCP/UDP端口），当有连接请求到达时，根据需要启动相应的服务程序，并将服务程序的输入输出描述符连接到对应的套接字。如果没有活动的请求需要处理，那么系统就不需要让服务程序运行，从而降低系统负载。</li>
<li>事务支持 launchd支持事务，会在系统关闭、用户退出或超过指定时间后检查未决的事物。</li>
<li>资源遏制和限制，例如jetsam机制可以强制实行虚拟内存使用率的限制。</li>
<li>I/O Kit整合 </li>
</ul>
<h3 id="2-3-LaunchdDaemon列表"><a href="#2-3-LaunchdDaemon列表" class="headerlink" title="2.3 LaunchdDaemon列表"></a>2.3 LaunchdDaemon列表</h3><p><img src="../../images/lauchdDaemon1.png" alt="avatar"><br><img src="../../images/lauchdDaemon2.png" alt="avatar"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://hexoman.github.io/2019/03/13/读书笔记之<<深入解析MAC OS X & iOS操作系统>>(二)/" data-id="cjxspmi5c001ryxonhqajvsix" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汇编/">汇编</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机系统/">计算机系统</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AutoreleasePool/">AutoreleasePool</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/block/">block</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/callAlloc/">callAlloc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/category/">category</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/isa/">isa</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/runtime/">runtime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/weak/">weak</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二分法/">二分法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/二叉树/">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/内存/">内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分布/">分布</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/回溯/">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图片优化/">图片优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/快排，冒泡/">快排，冒泡</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编译原理/">编译原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/链表/">链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/队列、栈/">队列、栈</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AutoreleasePool/" style="font-size: 10px;">AutoreleasePool</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/block/" style="font-size: 10px;">block</a> <a href="/tags/callAlloc/" style="font-size: 10px;">callAlloc</a> <a href="/tags/category/" style="font-size: 10px;">category</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/isa/" style="font-size: 10px;">isa</a> <a href="/tags/runtime/" style="font-size: 10px;">runtime</a> <a href="/tags/weak/" style="font-size: 10px;">weak</a> <a href="/tags/二分法/" style="font-size: 10px;">二分法</a> <a href="/tags/二叉树/" style="font-size: 10px;">二叉树</a> <a href="/tags/内存/" style="font-size: 10px;">内存</a> <a href="/tags/分布/" style="font-size: 10px;">分布</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/回溯/" style="font-size: 10px;">回溯</a> <a href="/tags/图片优化/" style="font-size: 10px;">图片优化</a> <a href="/tags/快排，冒泡/" style="font-size: 10px;">快排，冒泡</a> <a href="/tags/排序/" style="font-size: 20px;">排序</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/链表/" style="font-size: 20px;">链表</a> <a href="/tags/队列、栈/" style="font-size: 10px;">队列、栈</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/17/深入理解计算机系统/">深入理解计算机系统</a>
          </li>
        
          <li>
            <a href="/2019/05/04/swift学习笔记/">swift学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/04/01/汇编入门学习/">汇编入门学习</a>
          </li>
        
          <li>
            <a href="/2019/03/27/iOS中的链接器/">iOS中的链接器</a>
          </li>
        
          <li>
            <a href="/2019/03/24/<<程序员的自我修养>>之链接/">&lt;&lt;程序员的自我修养&gt;&gt;之链接</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 zw<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>